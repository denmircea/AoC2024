#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include<algorithm>
#include <string>
#include<set>
#include <math.h>
#include <stack>
#include <queue>
#include "aoc2024.h"

using namespace std;

ifstream fin("test.in");
ifstream fin2("test2.in");
ofstream fout("test.out");
map<char, pair<long long, long long>> mp,mpMic;
string levels;
string dfs3(char a, char b,long long level);
string dfs2(string input,long long level);
map < pair<pair<char, char>, long long>, string> memorizam; // avem char -- starting character, starting char 2 -- long long numarul de nivele pec are le rezolva
long long nivele = 25;
string dfs3(char a, char b,long long level) {
	auto p1 = mpMic[a];
	auto p2 = mpMic[b];
	long long x = p1.first - p2.first;
	long long y = p1.second - p2.second;
	// try to construct all paths frorm a to b, just manhattan
	long long upDown = 0;
	long long leftRight = 0;
	if (x > 0) {
		upDown = 1;
	}
	else if (x < 0) {
		upDown = -1;
	}
	if (y > 0) {
		leftRight = 1;
	}
	else if (y < 0) {
		leftRight = -1;
	}
	// create strings with each variant
	vector<pair<char, long long>> v;
	if (upDown == 1) {
		v.push_back({ '^', x });
	}
	else if (upDown == -1) {
		v.push_back({ 'v', -x });
	}
	if (leftRight == 1) {
		v.push_back({ '<', y });
	}
	else if (leftRight == -1) {
		v.push_back({ '>', -y });
	}
	vector<string> solutions;
	if (v.size() == 0) {
		solutions.push_back("A");
	}
	else if (v.size() == 1) {
		string aux = string(v[0].second, v[0].first);
		aux.push_back('A');
		solutions.push_back(aux);
	}
	else {
		string aux = "";
		auto InitPos = mpMic[a];
		bool valid = true;
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
			if (v[0].first == '^') {
				InitPos.first--;
			}
			else if (v[0].first == 'v') {
				InitPos.first++;
			}
			else if (v[0].first == '<') {
				InitPos.second--;
			}
			else if (v[0].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 0 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
		}
		aux.push_back('A');
		if (valid) {
			solutions.push_back(aux);
		}
		valid = true;
		aux = "";
		InitPos = mpMic[a];
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
			if (v[1].first == '^') {
				InitPos.first--;
			}
			else if (v[1].first == 'v') {
				InitPos.first++;
			}
			else if (v[1].first == '<') {
				InitPos.second--;
			}
			else if (v[1].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 0 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
		}
		aux.push_back('A');
		if (valid)
			solutions.push_back(aux);

	}
	return dfs2(solutions[0], level+1);
	/*if (solutions.size() == 2) {
		solutions.pop_back();
	}
	
	string res = string(10000, ' ');
	for (auto it : solutions) {
		string aux = dfs2(it,level+1);
		if (aux.size() < res.size()) {
			res = aux;
		}
	}
	return res;*/
		
}

string dfs2(string input,long long level) {
	if (level <10) {
		cout << level<<" ";
	}
	if (level == levels.size())
		return input;
	string fileName = "metadata/test" + to_string(level)+ "_" + to_string(rand()%1000000000) + to_string(rand()%1000000000)  + ".in";
	string result = "";
	for (auto it : input) {
		string res1;
		if (memorizam.find({ {levels[level], it}, nivele - level }) != memorizam.end()) {
			res1 = memorizam[{{levels[level], it}, nivele - level}];
		}
		else {
			res1 = dfs3(levels[level], it, level);
		}
		// filenameul
		if(level>=2)
			memorizam[{{levels[level], it}, nivele - level}] = res1;

		//result += res1;
		ifstream fin2(res1);
		ofstream fout2(fileName);
		char c;
		while (fin2 >> c) {
			fout2 << c;
		}
		fin2.close();
		fout2.close();
		levels[level] = it;
	}
	return result;
}

string dfs1(char a, char b) {
	auto p1 = mp[a];
	auto p2 = mp[b];
	long long x = p1.first - p2.first;
	long long y = p1.second - p2.second;
	// try to construct all paths frorm a to b, just manhattan
	long long upDown = 0;
	long long leftRight = 0;
	if (x > 0) {
		upDown = 1;
	}
	else if (x < 0) {
		upDown = -1;
	}
	if (y > 0) {
		leftRight = 1;
	}
	else if (y < 0) {
		leftRight = -1;
	}
	// create strings with each variant
	vector<pair<char, long long>> v;
	if (upDown == 1) {
		v.push_back({ '^', x });
	}
	else if (upDown == -1) {
		v.push_back({ 'v', -x });
	}
	if (leftRight == 1) {
		v.push_back({ '<', y });
	}
	else if (leftRight == -1) {
		v.push_back({ '>', -y });
	}
	vector<string> solutions;
	if (v.size() == 0) {
		solutions.push_back("A");
	}
	else if (v.size() == 1) {
		string aux = string(v[0].second, v[0].first);
		aux.push_back('A');
		solutions.push_back(aux);
	}
	else {
		string aux = "";
		auto InitPos = mp[a];
		bool valid = true;

		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
			if (v[0].first == '^') {
				InitPos.first--;
			}
			else if (v[0].first == 'v') {
				InitPos.first++;
			}
			else if (v[0].first == '<') {
				InitPos.second--;
			}
			else if (v[0].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 3 && InitPos.second == 0) {
				valid = false;
			}
		}
		
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
		}
		aux.push_back('A');
		if (valid) {
			solutions.push_back(aux);
		}
		valid = true;
		aux = "";
		InitPos = mp[a];
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
			if (v[1].first == '^') {
				InitPos.first--;
			}
			else if (v[1].first == 'v') {
				InitPos.first++;
			}
			else if (v[1].first == '<') {
				InitPos.second--;
			}
			else if (v[1].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 3 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
		}
		aux.push_back('A');
		if (valid)
			solutions.push_back(aux);
	}
	string res = string(10000, ' ');

	for (auto it : solutions) {
		string aux = dfs2(it,0);
		if (aux.size() < res.size()) {
			res = aux;
		}
	}
	return res;
}

int main() {
	mp['A'] = { 3,2 };
	mp['0'] = { 3,1 };
	mp['1'] = { 2,0 };
	mp['2'] = { 2,1 };
	mp['3'] = { 2,2 };
	mp['4'] = { 1,0 };
	mp['5'] = { 1,1 };
	mp['6'] = { 1,2 };
	mp['7'] = { 0,0 };
	mp['8'] = { 0,1 };
	mp['9'] = { 0,2 };
	mpMic['A'] = { 0,2 };
	mpMic['^'] = { 0,1 };
	mpMic['<'] = { 1,0 };
	mpMic['v'] = { 1,1 };
	mpMic['>'] = { 1,2 };

	string s;
	long long resp = 0;
	while (fin >> s) {
	long long sum = 0;
		auto it = 'A';
		levels = string(nivele, 'A');
		for (auto i2 : s) {
			auto it2 = i2;
			//cout<< dfs1(it, it2).size()<<" ";
			sum += dfs1(it, it2).size();
			it = it2;
		}
		long long nr = 0;
		for (auto i2 : s)
			if (i2 >= '0' && i2 <= '9')
				nr = nr * 10 + i2 - '0';
		resp += sum * nr;
	}
	cout << resp;
	return 0;
}





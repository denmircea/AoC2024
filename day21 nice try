#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include<algorithm>
#include <string>
#include<set>
#include <math.h>
#include <stack>
#include <queue>
#include "aoc2024.h"

using namespace std;

ifstream fin("test.in");
map<char, pair<long long, long long>> mp,mpMic;
string levels;

string dfs3(char a, char b,long long level);
string dfs2(string input,long long level);
set<string> files;
string generateFileName(long long level) {
	string name =  "metadata/" + to_string(level) + "_" + to_string(rand() % 1000000000) + "_" + to_string(rand() % 1000000000) + ".in";
	while (files.find(name) != files.end())
	{
		name = "metadata/" + to_string(level) + "_" + to_string(rand() % 1000000000) + "_" + to_string(rand() % 1000000000) + ".in";
	}
	files.insert(name);
	return name;
}

map < pair<pair<char, char>, long long>, string> memorizam; // avem char -- starting character, starting char 2 -- long long numarul de nivele pec are le rezolva
long long nivele = 25;
string dfs3(char a, char b, long long level) {
	auto p1 = mpMic[a];
	auto p2 = mpMic[b];
	long long x = p1.first - p2.first;
	long long y = p1.second - p2.second;
	// try to construct all paths frorm a to b, just manhattan
	long long upDown = 0;
	long long leftRight = 0;
	if (x > 0) {
		upDown = 1;
	}
	else if (x < 0) {
		upDown = -1;
	}
	if (y > 0) {
		leftRight = 1;
	}
	else if (y < 0) {
		leftRight = -1;
	}
	// create strings with each variant
	vector<pair<char, long long>> v;
	if (upDown == 1) {
		v.push_back({ '^', x });
	}
	else if (upDown == -1) {
		v.push_back({ 'v', -x });
	}
	if (leftRight == 1) {
		v.push_back({ '<', y });
	}
	else if (leftRight == -1) {
		v.push_back({ '>', -y });
	}
	vector<string> solutions;
	if (v.size() == 0) {
		solutions.push_back("A");
	}
	else if (v.size() == 1) {
		string aux = string(v[0].second, v[0].first);
		aux.push_back('A');
		solutions.push_back(aux);
	}
	else {
		string aux = "";
		auto InitPos = mpMic[a];
		bool valid = true;
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
			if (v[0].first == '^') {
				InitPos.first--;
			}
			else if (v[0].first == 'v') {
				InitPos.first++;
			}
			else if (v[0].first == '<') {
				InitPos.second--;
			}
			else if (v[0].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 0 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
		}
		aux.push_back('A');
		if (valid) {
			solutions.push_back(aux);
		}
		valid = true;
		aux = "";
		InitPos = mpMic[a];
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
			if (v[1].first == '^') {
				InitPos.first--;
			}
			else if (v[1].first == 'v') {
				InitPos.first++;
			}
			else if (v[1].first == '<') {
				InitPos.second--;
			}
			else if (v[1].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 0 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
		}
		aux.push_back('A');
		if (valid)
			solutions.push_back(aux);

	}
	string fileName = generateFileName(level);
	ofstream fout2(fileName);
	fout2 << solutions[0];
	fout2.close();

	return dfs2(fileName, level + 1);
	

}
string dfs2(string input,long long level) {
	if (level <10) {
		cout << level<<" ";
	}
	if (level == levels.size())
		return input;
	string fileName = generateFileName(level);
	ifstream fin3(input);
	ofstream fout2(fileName);
	char it;
	while(fin3>>it) {
		string res1;
		if (memorizam.find({ {levels[level], it}, nivele - level }) != memorizam.end()) {
			res1 = memorizam[{{levels[level], it}, nivele - level}];
		}
		else {
			res1 = dfs3(levels[level], it, level);

			// filenameul
			if (level > 4) {
				memorizam[{{levels[level], it}, nivele - level}] = res1;
			}
		}

		//result += res1;

		ifstream fin2(res1);
	
		char c;
		string s;
		const std::size_t bufferSize = 100000000; // Buffer size
		std::vector<char> buffer(bufferSize); // Buffer to store chunks of data
		while (fin2) {
			fin2.read(buffer.data(), bufferSize); // Read up to bufferSize characters
			streamsize bytesRead = fin2.gcount(); // Get the number of characters actually read
			fout2.write(buffer.data(), bytesRead); // Write the characters to the output file
		}
		if (level <= 4) {
			fin2.close(); // Close the file before reopening it
			ofstream fout33(res1);
			fout33 << '1';
			fout33.close();
		} else
		fin2.close();

		levels[level] = it;
	}
	fout2.close();
	fin3.close();
	return fileName;
}

long long dfs1(char a, char b) {
	auto p1 = mp[a];
	auto p2 = mp[b];
	long long x = p1.first - p2.first;
	long long y = p1.second - p2.second;
	// try to construct all paths frorm a to b, just manhattan
	long long upDown = 0;
	long long leftRight = 0;
	if (x > 0) {
		upDown = 1;
	}
	else if (x < 0) {
		upDown = -1;
	}
	if (y > 0) {
		leftRight = 1;
	}
	else if (y < 0) {
		leftRight = -1;
	}
	// create strings with each variant
	vector<pair<char, long long>> v;
	if (upDown == 1) {
		v.push_back({ '^', x });
	}
	else if (upDown == -1) {
		v.push_back({ 'v', -x });
	}
	if (leftRight == 1) {
		v.push_back({ '<', y });
	}
	else if (leftRight == -1) {
		v.push_back({ '>', -y });
	}
	vector<string> solutions;
	if (v.size() == 0) {
		solutions.push_back("A");
	}
	else if (v.size() == 1) {
		string aux = string(v[0].second, v[0].first);
		aux.push_back('A');
		solutions.push_back(aux);
	}
	else {
		string aux = "";
		auto InitPos = mp[a];
		bool valid = true;

		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
			if (v[0].first == '^') {
				InitPos.first--;
			}
			else if (v[0].first == 'v') {
				InitPos.first++;
			}
			else if (v[0].first == '<') {
				InitPos.second--;
			}
			else if (v[0].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 3 && InitPos.second == 0) {
				valid = false;
			}
		}
		
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
		}
		aux.push_back('A');
		if (valid) {
			solutions.push_back(aux);
		}
		valid = true;
		aux = "";
		InitPos = mp[a];
		for (long long i = 0; i < v[1].second; i++) {
			aux += v[1].first;
			if (v[1].first == '^') {
				InitPos.first--;
			}
			else if (v[1].first == 'v') {
				InitPos.first++;
			}
			else if (v[1].first == '<') {
				InitPos.second--;
			}
			else if (v[1].first == '>') {
				InitPos.second++;
			}
			if (InitPos.first == 3 && InitPos.second == 0) {
				valid = false;
			}
		}
		for (long long i = 0; i < v[0].second; i++) {
			aux += v[0].first;
		}
		aux.push_back('A');
		if (valid)
			solutions.push_back(aux);
	}
	long long sz1 = 0;
	long long sz2 = 0;
	string fileName = generateFileName(0);
	ofstream fout2;
	fout2.open(fileName);
	fout2 << solutions[0];
	fout2.close();
	string fileNameBig =  dfs2(fileName, 0);
	//cout << endl << fileNameBig << endl;//" ";
	char ch;
	ifstream fin2(fileNameBig);
	while (fin2 >> ch) {
		//cout << ch;
		sz1++;
	}
	if (solutions.size() > 1) {
		string fileName = generateFileName(0);
		ofstream fout2;
		fout2.open(fileName);
		fout2 << solutions[1];
		fout2.close();
		string fileNameBig = dfs2(fileName, 0);
		//cout << endl << fileNameBig << endl;//" ";
		char ch;
		ifstream fin2(fileNameBig);
		while (fin2 >> ch) {
			//cout << ch;
			sz2++;
		}
	}
	if (solutions.size() == 1)
		return sz1;
	return min(sz1,sz2);
	/*for (auto it : solutions) {
		string aux = dfs2(it,0);
		if (aux.size() < res.size()) {
			res = aux;
		}
	}
	return res;*/
}

int main() {
	mp['A'] = { 3,2 };
	mp['0'] = { 3,1 };
	mp['1'] = { 2,0 };
	mp['2'] = { 2,1 };
	mp['3'] = { 2,2 };
	mp['4'] = { 1,0 };
	mp['5'] = { 1,1 };
	mp['6'] = { 1,2 };
	mp['7'] = { 0,0 };
	mp['8'] = { 0,1 };
	mp['9'] = { 0,2 };
	mpMic['A'] = { 0,2 };
	mpMic['^'] = { 0,1 };
	mpMic['<'] = { 1,0 };
	mpMic['v'] = { 1,1 };
	mpMic['>'] = { 1,2 };

	string s;
	long long resp = 0;
	while (fin >> s) {
		long long sum = 0;
		auto it = 'A';
		levels = string(nivele, 'A');
		for (auto i2 : s) {
			auto it2 = i2;
			//cout<< dfs1(it, it2).size()<<" ";
			sum += dfs1(it, it2);

			it = it2;
		}
		long long nr = 0;
		for (auto i2 : s)
			if (i2 >= '0' && i2 <= '9')
				nr = nr * 10 + i2 - '0';
		resp += sum * nr;
	}
	cout <<"\nresp "<< resp;
	return 0;
}




